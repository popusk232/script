local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = workspace.CurrentCamera

local CrimLib = {}

CrimLib.Services = {
    UserInputService = UserInputService,
    TweenService = TweenService,
    CoreGui = CoreGui,
    Players = Players,
    LocalPlayer = LocalPlayer,
    RunService = RunService,
    ReplicatedStorage = ReplicatedStorage,
    Camera = Camera
}

-- Config and Constants will be initialized by the executable
CrimLib.Config = {
    CurrentConfigName = "...",
    ConfigToDeleteName = "...",
    UI_Elements = {}
}
CrimLib.Constants = {}

function CrimLib:init(configData, constants)
    self.Config.Data = configData
    self.Constants = constants
end


CrimLib.Features = {
    Connections = {},
    Ragebot_Coroutine = nil,
    Invis_AnimationTrack = nil,
    Invis_CamoAnim = Instance.new("Animation", getfenv().script),
}

local function json_encode(data)
    if type(_G.json_encode) == "function" then
        return pcall(_G.json_encode, data)
    elseif type(json) == "table" and type(json.encode) == "function" then
        return pcall(json.encode, data)
    end
    return false, "{}"
end

local function json_decode(data)
    if type(_G.json_decode) == "function" then
        return pcall(_G.json_decode, data)
    elseif type(json) == "table" and type(json.decode) == "function" then
        return pcall(json.decode, data)
    end
    return false, {}
end

local function has_file_io()
    return type(readfile) == "function" and type(writefile) == "function"
end

local function ensureConfigFolder()
    if has_file_io() and type(makefolder) == "function" then
        if type(isfolder) == "function" and not isfolder(CrimLib.Constants.CONFIG_FOLDER) then
            pcall(makefolder, CrimLib.Constants.CONFIG_FOLDER)
        elseif type(isfolder) ~= "function" then
             pcall(makefolder, CrimLib.Constants.CONFIG_FOLDER)
        end
    end
end

function CrimLib.Config:GetFileName(inputName)
    local C = CrimLib.Constants
    if not inputName or inputName == "" or inputName == "..." then
        return C.CONFIG_FOLDER .. C.DEFAULT_CONFIG_NAME .. C.CONFIG_EXTENSION
    end
    local name = string.gsub(inputName, C.CONFIG_EXTENSION .. "$", "")
    local fullPathPrefix = C.CONFIG_FOLDER
    name = string.gsub(name, "^" .. fullPathPrefix, "")
    name = string.gsub(name, "^%./" .. fullPathPrefix, "")
    name = string.gsub(name, "^%./", "")
    return C.CONFIG_FOLDER .. name .. C.CONFIG_EXTENSION
end

function CrimLib.Config:ListConfigFiles()
    local files = {}
    local C = CrimLib.Constants
    local fullPathPrefix = C.CONFIG_FOLDER
    if not has_file_io() then return files end
    if type(isfolder) == "function" and not isfolder(fullPathPrefix) then
        return files
    end
    local function cleanFileName(fileName)
        fileName = string.gsub(fileName, "^%./", "")
        fileName = string.gsub(fileName, "^" .. fullPathPrefix, "")
        if string.sub(fileName, -string.len(C.CONFIG_EXTENSION)) == C.CONFIG_EXTENSION then
            fileName = string.sub(fileName, 1, -string.len(C.CONFIG_EXTENSION) - 1)
        end
        return fileName
    end
    if type(listfiles) == "function" then
        local success, folderFiles = pcall(listfiles, fullPathPrefix)
        if success and folderFiles then
            for _, filenameWithExt in ipairs(folderFiles) do
                if string.sub(filenameWithExt, -string.len(C.CONFIG_EXTENSION)) == C.CONFIG_EXTENSION then
                    local configName = cleanFileName(filenameWithExt)
                    if configName ~= "" then table.insert(files, configName) end
                end
            end
        end
    end
    if #files == 0 and type(getregfiles) == "function" then
        local success, allFiles = pcall(getregfiles)
        if success and allFiles then
            for _, fullFileName in ipairs(allFiles) do
                if string.sub(fullFileName, -string.len(C.CONFIG_EXTENSION)) == C.CONFIG_EXTENSION then
                    local configName = cleanFileName(fullFileName)
                    if configName ~= "" then table.insert(files, configName) end
                end
            end
        end
    end
    local uniqueFiles = {}
    for _, name in ipairs(files) do
        uniqueFiles[name] = true
    end
    files = {}
    for name in pairs(uniqueFiles) do
        table.insert(files, name)
    end
    table.sort(files)
    return files
end

function CrimLib.Config:UpdateStatus(message, color)
    local label = CrimLib.Config.UI_Elements.ConfigDebugLabel
    if label then
        label.Text = message
        label.TextColor3 = color or Color3.fromRGB(200, 200, 200)
        task.delay(5, function()
            if label and label.Text == message then
                label.Text = ""
            end
        end)
    end
end

function CrimLib.Config:Save(fileName)
    if not has_file_io() then
        warn("[CrimLib Config] Save failed. Requires file I/O.")
        self:UpdateStatus("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –¥–æ—Å—Ç—É–ø –∫ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ.", Color3.fromRGB(200, 70, 70))
        return
    end
    ensureConfigFolder()
    local nameWithoutExt = string.gsub(fileName, CrimLib.Constants.CONFIG_EXTENSION .. "$", "")
    local finalFileName = self:GetFileName(nameWithoutExt)
    local encode_success, jsonString = json_encode(self.Data)
    local success = false
    if encode_success and type(jsonString) == "string" then
        success = pcall(writefile, finalFileName, jsonString)
    else
        warn("[CrimLib Config] Save failed: JSON Encoding failed: " .. tostring(jsonString or "unknown error"))
    end
    
    local SaveButton = CrimLib.Config.UI_Elements.SaveButton
    
    local originalColor = SaveButton and SaveButton.BackgroundColor3
    local statusText = success and ("–ö–æ–Ω—Ñ–∏–≥ '" .. nameWithoutExt .. "' —Å–æ—Ö—Ä–∞–Ω–µ–Ω.") or "–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: JSON / –ó–∞–ø–∏—Å—å —Ñ–∞–π–ª–∞."
    local statusColor = success and Color3.fromRGB(70, 200, 70) or Color3.fromRGB(200, 70, 70)

    self:UpdateStatus(statusText, statusColor)

    if SaveButton then
        SaveButton.Text = success and "–°–û–•–†–ê–ù–ï–ù–û!" or "–û–®–ò–ë–ö–ê!"
        SaveButton.BackgroundColor3 = statusColor
        if success then
             CrimLib.UI:PopulateConfigList(true)
             CrimLib.UI:PopulateDeleteConfigList(true)
        end
        task.wait(1)
        SaveButton.Text = "SAVE Config"
        SaveButton.BackgroundColor3 = originalColor
    end

    if success and nameWithoutExt ~= "" and nameWithoutExt ~= "..." then
        self.CurrentConfigName = nameWithoutExt
        if CrimLib.Config.UI_Elements.ConfigDisplayButton then
             CrimLib.Config.UI_Elements.ConfigDisplayButton.Text = "Current Config: " .. self.CurrentConfigName
        end
    end
end

function CrimLib.Config:Load(configName)
    if not has_file_io() then
        warn("[CrimLib Config] Load failed. Requires file I/O.")
        self:UpdateStatus("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –¥–æ—Å—Ç—É–ø –∫ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ.", Color3.fromRGB(200, 70, 70))
        return
    end
    local finalFileName = self:GetFileName(configName)
    local loadedData
    local read_success, jsonString = false, nil
    if isfile(finalFileName) then
        read_success, jsonString = pcall(readfile, finalFileName)
    end
    local decode_success = false
    if read_success and type(jsonString) == "string" and jsonString ~= "" then
        decode_success, loadedData = json_decode(jsonString)
    end
    
    local LoadButton = CrimLib.Config.UI_Elements.LoadButton
    local originalColor = LoadButton and LoadButton.BackgroundColor3
    
    local apply_success = false
    if decode_success and type(loadedData) == "table" then
        apply_success, _ = pcall(function()
            for k, v in pairs(loadedData) do
                self.Data[k] = v
            end
        end)
    end
    
    if apply_success then
        CrimLib.UI:ApplyConfigToUI()
        self.CurrentConfigName = configName
        if CrimLib.Config.UI_Elements.ConfigDisplayButton then
            CrimLib.Config.UI_Elements.ConfigDisplayButton.Text = "Current Config: " .. configName
        end
        
        self:UpdateStatus("–ö–æ–Ω—Ñ–∏–≥ '" .. configName .. "' –∑–∞–≥—Ä—É–∂–µ–Ω.", Color3.fromRGB(70, 200, 70))

        if LoadButton then
            LoadButton.Text = "–ó–ê–ì–†–£–ñ–ï–ù–û!"
            LoadButton.BackgroundColor3 = Color3.fromRGB(70, 200, 70)
            task.wait(1)
            LoadButton.Text = "LOAD Config"
            LoadButton.BackgroundColor3 = originalColor
        end
    else
        local errorText = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: "
        local errorColor = Color3.fromRGB(200, 70, 70)
        if not read_success or not isfile(finalFileName) then
            errorText = "–§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥–∞ '" .. configName .. "' –Ω–µ –Ω–∞–π–¥–µ–Ω."
            errorColor = Color3.fromRGB(200, 150, 70)
        elseif not decode_success then
            errorText = "–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON."
        else
            errorText = "–ü–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ."
        end
        
        self:UpdateStatus(errorText, errorColor)

        self.CurrentConfigName = "..."
        if CrimLib.Config.UI_Elements.ConfigDisplayButton then
            CrimLib.Config.UI_Elements.ConfigDisplayButton.Text = "Current Config: ..."
        end

        if LoadButton then
            LoadButton.Text = "–û–®–ò–ë–ö–ê!"
            LoadButton.BackgroundColor3 = errorColor
            task.wait(1)
            LoadButton.Text = "LOAD Config"
            LoadButton.BackgroundColor3 = originalColor
        end
    end
end

function CrimLib.Config:Delete(configName)
    if not has_file_io() or type(delfile) ~= "function" then
        warn("[CrimLib Config] Delete failed. Requires file I/O and delfile function.")
        self:UpdateStatus("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –¥–æ—Å—Ç—É–ø –∫ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ.", Color3.fromRGB(200, 70, 70))
        return false
    end
    local finalFileName = self:GetFileName(configName)
    local DeleteButton = CrimLib.Config.UI_Elements.DeleteButton
    
    if type(isfile) == "function" and not isfile(finalFileName) then
        self:UpdateStatus("–û—à–∏–±–∫–∞: –§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥–∞ '" .. configName .. "' –Ω–µ –Ω–∞–π–¥–µ–Ω.", Color3.fromRGB(200, 150, 70))
        if DeleteButton then
            local originalColor = DeleteButton.BackgroundColor3
            DeleteButton.Text = "–ù–ï –ù–ê–ô–î–ï–ù–û"
            DeleteButton.BackgroundColor3 = Color3.fromRGB(200, 150, 70)
            task.wait(1.5)
            DeleteButton.Text = "DELETE Config"
            DeleteButton.BackgroundColor3 = originalColor
        end
        CrimLib.UI:PopulateConfigList(true)
        CrimLib.UI:PopulateDeleteConfigList(true)
        self.ConfigToDeleteName = "..."
        if CrimLib.Config.UI_Elements.DeleteConfigDisplayButton then
             CrimLib.Config.UI_Elements.DeleteConfigDisplayButton.Text = "Config to Delete: ..."
        end
        return false
    end
    
    local success, err = pcall(delfile, finalFileName)
    
    if DeleteButton then
        local originalColor = DeleteButton.BackgroundColor3
        local statusText, statusColor
        if success then
            statusText = "–ö–æ–Ω—Ñ–∏–≥ '" .. configName .. "' —É–¥–∞–ª–µ–Ω."
            statusColor = Color3.fromRGB(255, 60, 60)
            
            if self.CurrentConfigName == configName then
                self.CurrentConfigName = "..."
                if CrimLib.Config.UI_Elements.ConfigDisplayButton then
                    CrimLib.Config.UI_Elements.ConfigDisplayButton.Text = "Current Config: ..."
                    if CrimLib.Config.UI_Elements.ConfigArrow then CrimLib.Config.UI_Elements.ConfigArrow.Text = "‚ñ∫" end
                end
            end
            CrimLib.UI:PopulateConfigList(true)
            CrimLib.UI:PopulateDeleteConfigList(true)
            self.ConfigToDeleteName = "..."
            if CrimLib.Config.UI_Elements.DeleteConfigDisplayButton then
                 CrimLib.Config.UI_Elements.DeleteConfigDisplayButton.Text = "Config to Delete: ..."
                 if CrimLib.Config.UI_Elements.DeleteArrow then CrimLib.Config.UI_Elements.DeleteArrow.Text = "‚ñ∫" end
            end
        else
            statusText = "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞ '" .. configName .. "': " .. tostring(err)
            statusColor = Color3.fromRGB(200, 70, 70)
        end
        
        self:UpdateStatus(statusText, statusColor)

        DeleteButton.Text = success and "–£–î–ê–õ–ï–ù–û!" or "–û–®–ò–ë–ö–ê!"
        DeleteButton.BackgroundColor3 = statusColor
        task.wait(1.5)
        DeleteButton.Text = "DELETE Config"
        DeleteButton.BackgroundColor3 = originalColor
        return success
    end
    return success
end


-- Features
function CrimLib.Features:Attack(target)
    if not target or not target:FindFirstChild("Head") then return end
    local character = LocalPlayer.Character
    local tool = character and character:FindFirstChildOfClass("Tool")
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not tool or not humanoidRootPart then return end
    
    local remoteFunction = ReplicatedStorage:FindFirstChild("Events", true) and ReplicatedStorage.Events:FindFirstChild("XMHH.2")
    local remoteEvent = ReplicatedStorage:FindFirstChild("Events", true) and ReplicatedStorage.Events:FindFirstChild("XMHH2.2")
    if not remoteFunction or not remoteEvent then return end

    local args1 = { "üçû", tick(), tool, "43TRFWX", "Normal", tick(), true }
    local success1, result = pcall(function() return remoteFunction:InvokeServer(unpack(args1)) end)
    if not success1 then return end
    task.wait(0.1)
    local handle = tool:FindFirstChild("WeaponHandle") or tool:FindFirstChild("Handle") or (character and character:FindFirstChild("Right Arm"))
    local head = target:FindFirstChild("Head")
    if handle and head then
        local args2 = { "üçû", tick(), tool, "2389ZFX34", result, false, handle, head, target, humanoidRootPart.Position, head.Position }
        pcall(function() remoteEvent:FireServer(unpack(args2)) end)
    end
end

function CrimLib.Features:MeleeAuraEnable()
    local Config = CrimLib.Config
    if Config.Data.MeleeAura_Enabled then return end
    Config.Data.MeleeAura_Enabled = true
    if self.Connections.MeleeAura then self.Connections.MeleeAura:Disconnect() end
    
    self.Connections.MeleeAura = RunService.RenderStepped:Connect(function()
        if not Config.Data.MeleeAura_Enabled then return end
        local character = LocalPlayer.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= LocalPlayer then
                local otherCharacter = otherPlayer.Character
                local otherHRP = otherCharacter and otherCharacter:FindFirstChild("HumanoidRootPart")
                local otherHumanoid = otherCharacter and otherCharacter:FindFirstChildOfClass("Humanoid")
                if otherHRP and otherHumanoid then
                    local distance = (humanoidRootPart.Position - otherHRP.Position).Magnitude
                    if distance < Config.Data.MeleeAura_Distance and otherHumanoid.Health > 15 and not otherCharacter:FindFirstChildOfClass("ForceField") then
                        self:Attack(otherCharacter)
                    end
                end
            end
        end
    end)
end

function CrimLib.Features:MeleeAuraDisable()
    local Config = CrimLib.Config
    if not Config.Data.MeleeAura_Enabled then return end
    Config.Data.MeleeAura_Enabled = false
    if self.Connections.MeleeAura then
        self.Connections.MeleeAura:Disconnect()
        self.Connections.MeleeAura = nil
    end
end

function CrimLib.Features:FovEnable()
    CrimLib.Config.Data.Fov_Enabled = true
    if self.Connections.Fov then self.Connections.Fov:Disconnect() end
    self.Connections.Fov = RunService.RenderStepped:Connect(function()
        if CrimLib.Config.Data.Fov_Enabled then
            Camera.FieldOfView = CrimLib.Config.Data.Fov_Value
        end
    end)
end

function CrimLib.Features:FovDisable()
    CrimLib.Config.Data.Fov_Enabled = false
    if self.Connections.Fov then
        self.Connections.Fov:Disconnect()
        self.Connections.Fov = nil
    end
    pcall(function() Camera.FieldOfView = workspace.CurrentCamera.FieldOfView end)
end

function CrimLib.Features:GetClosestEnemy()
    local myCharacter = LocalPlayer.Character
    local myHRP = myCharacter and myCharacter:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    local closestEnemy = nil
    local shortestDistance = CrimLib.Config.Data.Ragebot_MaxDistance
    local Config = CrimLib.Config.Data

    if Config.Ragebot_TargetMode == "Distance" then
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= LocalPlayer then
                if (not Config.Ragebot_UseNameTarget or otherPlayer.Name == Config.Ragebot_TargetName) then
                    local enemyCharacter = otherPlayer.Character
                    local enemyHRP = enemyCharacter and enemyCharacter:FindFirstChild("HumanoidRootPart")
                    local enemyHumanoid = enemyCharacter and enemyCharacter:FindFirstChildOfClass("Humanoid")
                    if enemyHRP and enemyHumanoid and enemyHumanoid.Health > Config.Ragebot_MinHealth and not enemyCharacter:FindFirstChildOfClass("ForceField") then
                        local distance = (myHRP.Position - enemyHRP.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            closestEnemy = otherPlayer
                        end
                    end
                end
            end
        end
    elseif Config.Ragebot_TargetMode == "Crosshair" then
        local minCrosshairDist = math.huge
        local viewportCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= LocalPlayer then
                if (not Config.Ragebot_UseNameTarget or otherPlayer.Name == Config.Ragebot_TargetName) then
                    local enemyCharacter = otherPlayer.Character
                    local enemyHRP = enemyCharacter and enemyCharacter:FindFirstChild("HumanoidRootPart")
                    local enemyHumanoid = enemyCharacter and enemyCharacter:FindFirstChildOfClass("Humanoid")
                    if enemyHRP and enemyHumanoid and enemyHumanoid.Health > Config.Ragebot_MinHealth and not enemyCharacter:FindFirstChildOfClass("ForceField") then
                        local distance3D = (myHRP.Position - enemyHRP.Position).Magnitude
                        if distance3D < shortestDistance then
                            local screenPos, onScreen = Camera:WorldToScreenPoint(enemyHRP.Position)
                            if onScreen then
                                local crosshairDist = (Vector2.new(screenPos.X, screenPos.Y) - viewportCenter).Magnitude
                                if crosshairDist < minCrosshairDist then
                                    minCrosshairDist = crosshairDist
                                    closestEnemy = otherPlayer
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return closestEnemy
end

function CrimLib.Features:Shoot(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return end
    local targetPart = targetPlayer.Character:FindFirstChild("Head") or targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end
    local myCharacter = LocalPlayer.Character
    local tool = myCharacter and myCharacter:FindFirstChildOfClass("Tool")
    if not tool then return end

    local remote1_Rage = ReplicatedStorage:FindFirstChild("Events", true) and ReplicatedStorage.Events:FindFirstChild("GNX_S")
    local remote2_Rage = ReplicatedStorage:FindFirstChild("Events", true) and ReplicatedStorage.Events:FindFirstChild("ZFKLF__H")
    if not remote1_Rage or not remote2_Rage then return end

    local randomKey = string.rep(string.char(math.random(97, 122)), 30) .. "0"
    local hitDirection = (targetPart.Position - Camera.CFrame.Position).Unit

    pcall(function() remote1_Rage:FireServer(tick(), randomKey, tool, "FDS9I83", Camera.CFrame.Position, {hitDirection}, false) end)
    pcall(function() remote2_Rage:FireServer("üßà", tool, randomKey, 1, targetPart, targetPart.Position, hitDirection, nil, nil) end)
end

function CrimLib.Features:UpdateTargetInfoWindow(targetPlayer)
    local TargetInfoWindow = CrimLib.Config.UI_Elements.TargetInfoWindow
    if not TargetInfoWindow then return end

    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") or not targetPlayer.Character:FindFirstChildOfClass("Humanoid") then
        TargetInfoWindow.Visible = false
        return
    end

    TargetInfoWindow.Visible = true
    local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")

    local healthPercent = humanoid.Health / humanoid.MaxHealth
    local distance = myHRP and (myHRP.Position - targetHRP.Position).Magnitude or 0

    TargetInfoWindow.TargetNameLabel.Text = targetPlayer.Name
    TargetInfoWindow.TargetDistanceLabel.Text = string.format("Dist: %.1fm", distance)
    TargetInfoWindow.HealthBarBackground.HealthTextLabel.Text = string.format("%.0f%%", healthPercent * 100)
    TargetInfoWindow.HealthBarBackground.HealthBarFill.Size = UDim2.new(healthPercent, 0, 1, 0)
end

function CrimLib.Features:RagebotLoop()
    while CrimLib.Config.Data.Ragebot_Enabled do
        local target = self:GetClosestEnemy()
        self:UpdateTargetInfoWindow(target)
        if target then
            self:Shoot(target)
            task.wait(0.05)
        else
            task.wait(0.1)
        end
    end
    self.Ragebot_Coroutine = nil
    self:UpdateTargetInfoWindow(nil)
end

function CrimLib.Features:RagebotEnable()
    if CrimLib.Config.Data.Ragebot_Enabled then return end
    CrimLib.Config.Data.Ragebot_Enabled = true
    if not self.Ragebot_Coroutine then
        self.Ragebot_Coroutine = coroutine.create(function() self:RagebotLoop() end)
        coroutine.resume(self.Ragebot_Coroutine)
    end
end

function CrimLib.Features:RagebotDisable()
    if not CrimLib.Config.Data.Ragebot_Enabled then return end
    CrimLib.Config.Data.Ragebot_Enabled = false
    self:UpdateTargetInfoWindow(nil)
end

function CrimLib.Features:InfiniteStaminaEnable()
    local Config = CrimLib.Config
    if Config.Data.InfiniteStamina_Enabled then return end
    Config.Data.InfiniteStamina_Enabled = true
    if self.Connections.InfiniteStamina then self.Connections.InfiniteStamina:Disconnect() end
    self.Connections.InfiniteStamina = RunService.RenderStepped:Connect(function()
        if not Config.Data.InfiniteStamina_Enabled then return end
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and not humanoid:GetAttribute("ZSPRN_M") then
            humanoid:SetAttribute("ZSPRN_M", true)
        end
    end)
end

function CrimLib.Features:InfiniteStaminaDisable()
    local Config = CrimLib.Config
    if not Config.Data.InfiniteStamina_Enabled then return end
    Config.Data.InfiniteStamina_Enabled = false
    if self.Connections.InfiniteStamina then
        self.Connections.InfiniteStamina:Disconnect()
        self.Connections.InfiniteStamina = nil
    end
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid:GetAttribute("ZSPRN_M") then
        humanoid:SetAttribute("ZSPRN_M", nil)
    end
end

function CrimLib.Features:InvisibilityStep(deltaTime)
    local Config = CrimLib.Config
    if not Config.Data.Invisibility_Enabled then return end
    
    local char = LocalPlayer.Character
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not char or not humanoid or not hrp then return end

    local Invis_WarningLabel = CrimLib.Config.UI_Elements.Invis_WarningLabel
    if Invis_WarningLabel then
        Invis_WarningLabel.Visible = humanoid.FloorMaterial == Enum.Material.Air
    end

    if humanoid.MoveDirection.Magnitude > 0 then
        hrp.CFrame = hrp.CFrame + humanoid.MoveDirection * 12 * deltaTime
    end

    local originalCFrame = hrp.CFrame
    local originalCameraOffset = humanoid.CameraOffset
    local _, yawAngle = Camera.CFrame:ToOrientation()
    hrp.CFrame = CFrame.new(hrp.CFrame.Position) * CFrame.fromOrientation(0, yawAngle, 0) * CFrame.Angles(math.rad(90), 0, 0)
    humanoid.CameraOffset = Vector3.new(0, 1.44, 0)

    if self.Invis_AnimationTrack then
        local success = pcall(function()
            if not self.Invis_AnimationTrack.IsPlaying then self.Invis_AnimationTrack:Play() end
            self.Invis_AnimationTrack:AdjustSpeed(0)
            self.Invis_AnimationTrack.TimePosition = 0.3
        end)
        if not success then self:LoadAnimationTrack() end
    end

    RunService.RenderStepped:Wait()

    if humanoid and humanoid:IsDescendantOf(workspace) then humanoid.CameraOffset = originalCameraOffset end
    if hrp and hrp:IsDescendantOf(workspace) then hrp.CFrame = originalCFrame end
    if self.Invis_AnimationTrack then pcall(function() self.Invis_AnimationTrack:Stop() end) end

    if hrp and hrp:IsDescendantOf(workspace) then
        local flatLook = Vector3.new(Camera.CFrame.LookVector.X, 0, Camera.CFrame.LookVector.Z).Unit
        if flatLook.Magnitude > 0.1 then
            hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + flatLook)
        end
    end

    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") and part.Transparency ~= 1 then part.Transparency = 0.5 end
    end
end

function CrimLib.Features:LoadAnimationTrack()
    if self.Invis_AnimationTrack then pcall(function() self.Invis_AnimationTrack:Stop() end) self.Invis_AnimationTrack = nil end
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local success, result = pcall(function() return humanoid:LoadAnimation(self.Invis_CamoAnim) end)
        if success then self.Invis_AnimationTrack = result self.Invis_AnimationTrack.Priority = Enum.AnimationPriority.Action4 end
    end
end

function CrimLib.Features:InvisibilityEnable()
    local Config = CrimLib.Config
    if Config.Data.Invisibility_Enabled then return end
    local char = LocalPlayer.Character
    if not (char and char:FindFirstChild("Torso")) then warn("Invisibility requires R6!") return end

    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end
    
    Config.Data.Invisibility_Enabled = true
    Camera.CameraSubject = hrp
    self:LoadAnimationTrack()

    if self.Connections.InvisHeartbeat then self.Connections.InvisHeartbeat:Disconnect() end
    self.Connections.InvisHeartbeat = RunService.Heartbeat:Connect(function(dt) self:InvisibilityStep(dt) end)
end

function CrimLib.Features:InvisibilityDisable()
    local Config = CrimLib.Config
    if not Config.Data.Invisibility_Enabled then return end
    Config.Data.Invisibility_Enabled = false

    if self.Connections.InvisHeartbeat then self.Connections.InvisHeartbeat:Disconnect() self.Connections.InvisHeartbeat = nil end
    if self.Invis_AnimationTrack then pcall(function() self.Invis_AnimationTrack:Stop() end) end

    local char = LocalPlayer.Character
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    if humanoid then Camera.CameraSubject = humanoid end

    if char then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and part.Transparency == 0.5 then part.Transparency = 0 end
        end
    end
    if CrimLib.Config.UI_Elements.Invis_WarningLabel then CrimLib.Config.UI_Elements.Invis_WarningLabel.Visible = false end
end

function CrimLib.Features:InitInvisibility()
    self.Invis_CamoAnim.AnimationId = "rbxassetid://215384594"
    self.Connections.InvisCharAdded = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        self:InvisibilityDisable()
        if self.Invis_AnimationTrack then pcall(function() self.Invis_AnimationTrack:Stop() end) self.Invis_AnimationTrack = nil end
        task.wait(0.5)
        if CrimLib.Config.Data.Invisibility_Enabled then self:InvisibilityEnable() end
    end)

    self.Connections.InvisCharRemoving = LocalPlayer.CharacterRemoving:Connect(function()
        if self.Invis_AnimationTrack then pcall(function() self.Invis_AnimationTrack:Stop() end) self.Invis_AnimationTrack = nil end
        if CrimLib.Config.UI_Elements.Invis_WarningLabel then CrimLib.Config.UI_Elements.Invis_WarningLabel.Visible = false end
    end)
end

CrimLib.UI = {}

function CrimLib.UI:Create()
    local Config = CrimLib.Config
    local Features = CrimLib.Features
    local Constants = CrimLib.Constants
    local Services = CrimLib.Services
    local TweenService = Services.TweenService
    local CoreGui = Services.CoreGui

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "RagebotUI"
    ScreenGui.Parent = CoreGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.ResetOnSpawn = false

    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ScreenGui
    MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    MainFrame.BorderSizePixel = 0
    MainFrame.Position = UDim2.new(0.5, -421.5, 0.5, -287.5)
    MainFrame.Size = UDim2.new(0, 843, 0, 575)
    MainFrame.Visible = false
    MainFrame.Active = true
    Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 8)

    local Header = Instance.new("Frame")
    Header.Name = "Header"
    Header.Parent = MainFrame
    Header.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
    Header.BorderSizePixel = 0
    Header.Size = UDim2.new(1, 0, 0, 60)
    Instance.new("UICorner", Header).CornerRadius = UDim.new(0, 8)
    
    local LogoIcon = Instance.new("ImageLabel", Header)
    LogoIcon.BackgroundTransparency = 1
    LogoIcon.Position = UDim2.new(0, 20, 0, 12)
    LogoIcon.Size = UDim2.new(0, 36, 0, 36)
    LogoIcon.Image = "rbxassetid://97446581390925"

    local Title = Instance.new("TextLabel", Header)
    Title.BackgroundTransparency = 1
    Title.Position = UDim2.new(0, 70, 0, 18)
    Title.Size = UDim2.new(0, 200, 0, 24)
    Title.Font = Enum.Font.GothamBold
    Title.Text = "Ragebot"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextSize = 20
    Title.TextXAlignment = Enum.TextXAlignment.Left

    local Sidebar = Instance.new("Frame", MainFrame)
    Sidebar.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
    Sidebar.BorderSizePixel = 0
    Sidebar.Position = UDim2.new(0, 0, 0, 60)
    Sidebar.Size = UDim2.new(0, 70, 0, 515)

    local ContentFrame = Instance.new("Frame", MainFrame)
    ContentFrame.BackgroundTransparency = 1
    ContentFrame.Position = UDim2.new(0, 70, 0, 60)
    ContentFrame.Size = UDim2.new(1, -70, 1, -60)
    ContentFrame.ClipsDescendants = true
    
    local TargetInfoWindow = Instance.new("Frame")
    TargetInfoWindow.Name = "TargetInfoWindow"
    TargetInfoWindow.Parent = MainFrame
    TargetInfoWindow.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
    TargetInfoWindow.BorderSizePixel = 1
    TargetInfoWindow.BorderColor3 = Color3.fromRGB(35, 35, 35)
    TargetInfoWindow.Position = UDim2.new(0.5, -150, 1, -80)
    TargetInfoWindow.Size = UDim2.new(0, 300, 0, 70)
    TargetInfoWindow.Visible = false
    Instance.new("UICorner", TargetInfoWindow).CornerRadius = UDim.new(0, 6)

    local TargetNameLabel = Instance.new("TextLabel")
    TargetNameLabel.Name = "TargetNameLabel"
    TargetNameLabel.Parent = TargetInfoWindow
    TargetNameLabel.BackgroundTransparency = 1
    TargetNameLabel.Size = UDim2.new(1, -10, 0, 20)
    TargetNameLabel.Position = UDim2.new(0, 5, 0, 5)
    TargetNameLabel.Font = Enum.Font.GothamBold
    TargetNameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TargetNameLabel.TextSize = 14
    TargetNameLabel.Text = "Target: None"
    TargetNameLabel.TextXAlignment = Enum.TextXAlignment.Left

    local TargetDistanceLabel = Instance.new("TextLabel")
    TargetDistanceLabel.Name = "TargetDistanceLabel"
    TargetDistanceLabel.Parent = TargetInfoWindow
    TargetDistanceLabel.BackgroundTransparency = 1
    TargetDistanceLabel.Size = UDim2.new(1, -10, 0, 20)
    TargetDistanceLabel.Position = UDim2.new(0, 5, 0, 5)
    TargetDistanceLabel.Font = Enum.Font.Gotham
    TargetDistanceLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    TargetDistanceLabel.TextSize = 12
    TargetDistanceLabel.Text = "Dist: 0m"
    TargetDistanceLabel.TextXAlignment = Enum.TextXAlignment.Right

    local HealthBarBackground = Instance.new("Frame")
    HealthBarBackground.Name = "HealthBarBackground"
    HealthBarBackground.Parent = TargetInfoWindow
    HealthBarBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    HealthBarBackground.BorderSizePixel = 0
    HealthBarBackground.Position = UDim2.new(0.5, -145, 0, 45)
    HealthBarBackground.Size = UDim2.new(1, -10, 0, 15)
    Instance.new("UICorner", HealthBarBackground).CornerRadius = UDim.new(0, 3)

    local HealthBarFill = Instance.new("Frame")
    HealthBarFill.Name = "HealthBarFill"
    HealthBarFill.Parent = HealthBarBackground
    HealthBarFill.BackgroundColor3 = Color3.fromRGB(70, 200, 70)
    HealthBarFill.BorderSizePixel = 0
    HealthBarFill.Size = UDim2.new(1, 0, 1, 0)
    Instance.new("UICorner", HealthBarFill).CornerRadius = UDim.new(0, 3)

    local HealthTextLabel = Instance.new("TextLabel")
    HealthTextLabel.Name = "HealthTextLabel"
    HealthTextLabel.Parent = HealthBarBackground
    HealthTextLabel.BackgroundTransparency = 1
    HealthTextLabel.Size = UDim2.new(1, 0, 1, 0)
    HealthTextLabel.Font = Enum.Font.GothamBold
    HealthTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    HealthTextLabel.TextSize = 10
    HealthTextLabel.Text = "100%"

    local currentTab = 1
    local tabs = {}
    local ContentContainers = {}
    local sidebarIcons = {
        {icon = "rbxassetid://98370306170658", y = 15, name = "Combat", size = {16.9, 16.9}},
        {icon = "rbxassetid://127827492424396", y = 85, name = "Visuals", size = {28, 26}},
        {icon = "rbxassetid://100545076798978", y = 155, name = "World", size = {32, 32}},
        {icon = "rbxassetid://100545076798978", y = 225, name = "Scripts", size = {32, 32}}, 
        {icon = "rbxassetid://107710676270056", y = 295, name = "Misc", size = {37, 35}},
        {icon = "rbxassetid://97047003599965", y = 365, name = "Config", size = {20, 20}}
    }
    local function createTabContent(name, index)
        local TabContainer = Instance.new("Frame")
        TabContainer.Name = name .. "Content"
        TabContainer.Parent = ContentFrame
        TabContainer.BackgroundTransparency = 1
        TabContainer.Size = UDim2.new(1, 0, 1, 0)
        TabContainer.Visible = index == currentTab
        ContentContainers[index] = TabContainer
        return TabContainer
    end
    local CombatContent = createTabContent("Combat", 1)
    local VisualsContent = createTabContent("Visuals", 2)
    local WorldContent = createTabContent("World", 3)
    local ScriptsContent = createTabContent("Scripts", 4)
    local MiscContent = createTabContent("Misc", 5)
    local ConfigContent = createTabContent("Config", 6)
    tabs[1] = {name = "Combat", content = CombatContent}
    tabs[2] = {name = "Visuals", content = VisualsContent}
    tabs[3] = {name = "World", content = WorldContent}
    tabs[4] = {name = "Scripts", content = ScriptsContent}
    tabs[5] = {name = "Misc", content = MiscContent}
    tabs[6] = {name = "Config", content = ConfigContent}
    local function switchTab(index, iconData)
        for i, tab in ipairs(tabs) do
            local frame = Sidebar:FindFirstChild("Tab_" .. i)
            if frame then
                local indicator = frame:FindFirstChild("Indicator")
                local isActive = i == index
                local targetColor = isActive and Color3.fromRGB(25, 25, 25) or Color3.fromRGB(18, 18, 18)
                local targetIndicatorSize = isActive and UDim2.new(0, 4, 1, 0) or UDim2.new(0, 0, 1, 0)
                TweenService:Create(frame, TweenInfo.new(0.2), {BackgroundColor3 = targetColor}):Play()
                TweenService:Create(indicator, TweenInfo.new(0.2), {Size = targetIndicatorSize}):Play()
            end
            if tab.content then
                tab.content.Visible = false
            end
        end
        currentTab = index
        Title.Text = iconData.name
        if ContentContainers[index] then
            ContentContainers[index].Visible = true
        end
    end
    for index, iconData in ipairs(sidebarIcons) do
        local IconFrame = Instance.new("Frame")
        IconFrame.Parent = Sidebar
        IconFrame.Name = "Tab_" .. index
        IconFrame.BackgroundColor3 = index == currentTab and Color3.fromRGB(25, 25, 25) or Color3.fromRGB(18, 18, 18)
        IconFrame.BorderSizePixel = 0
        IconFrame.Position = UDim2.new(0, 0, 0, iconData.y)
        IconFrame.Size = UDim2.new(1, 0, 0, 60)
        local ActiveIndicator = Instance.new("Frame")
        ActiveIndicator.Parent = IconFrame
        ActiveIndicator.Name = "Indicator"
        ActiveIndicator.BackgroundColor3 = Color3.fromRGB(60, 160, 255)
        ActiveIndicator.BorderSizePixel = 0
        ActiveIndicator.Position = UDim2.new(0, 0, 0, 0)
        ActiveIndicator.Size = UDim2.new(0, index == currentTab and 4 or 0, 1, 0)
        local Icon = Instance.new("ImageLabel")
        Icon.Parent = IconFrame
        Icon.BackgroundTransparency = 1
        Icon.Position = UDim2.new(0.5, -iconData.size[1]/2, 0.5, -iconData.size[2]/2)
        Icon.Size = UDim2.new(0, iconData.size[1], 0, iconData.size[2])
        Icon.Image = iconData.icon
        Icon.ImageColor3 = Color3.fromRGB(200, 200, 200)
        Icon.ScaleType = Enum.ScaleType.Fit
        local TabButton = Instance.new("TextButton")
        TabButton.Parent = IconFrame
        TabButton.BackgroundTransparency = 1
        TabButton.Size = UDim2.new(1, 0, 1, 0)
        TabButton.Text = ""
        TabButton.ZIndex = 3
        TabButton.MouseButton1Click:Connect(function()
            switchTab(index, iconData)
        end)
        TabButton.MouseEnter:Connect(function()
            if currentTab ~= index then
                TweenService:Create(IconFrame, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(22, 22, 22)}):Play()
            end
        end)
        TabButton.MouseLeave:Connect(function()
            if currentTab ~= index then
                TweenService:Create(IconFrame, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(18, 18, 18)}):Play()
            end
        end)
    end
    
    -- Assign to UI_Elements table for later access
    Config.UI_Elements.ScreenGui = ScreenGui
    Config.UI_Elements.MainFrame = MainFrame
    Config.UI_Elements.Title = Title
    Config.UI_Elements.TargetInfoWindow = TargetInfoWindow
    Config.UI_Elements.TargetNameLabel = TargetNameLabel
    Config.UI_Elements.TargetDistanceLabel = TargetDistanceLabel
    Config.UI_Elements.HealthBarFill = HealthBarFill
    Config.UI_Elements.HealthTextLabel = HealthTextLabel
    Config.UI_Elements.CombatContent = CombatContent
    Config.UI_Elements.VisualsContent = VisualsContent
    Config.UI_Elements.WorldContent = WorldContent
    Config.UI_Elements.SkinChangerContent = SkinChangerContent
    Config.UI_Elements.MiscContent = MiscContent
    Config.UI_Elements.ConfigContent = ConfigContent

    self:ApplyConfigToUI() -- Apply initial config values
    
    return ScreenGui
end

function CrimLib.UI:ApplyConfigToUI()
    local ConfigData = CrimLib.Config.Data
    local UIElements = CrimLib.Config.UI_Elements

    -- Melee Aura
    if UIElements.MeleeAuraToggle then
        UIElements.MeleeAuraToggle.BackgroundColor3 = ConfigData.MeleeAura_Enabled and Color3.fromRGB(70, 200, 70) or Color3.fromRGB(35, 35, 35)
        UIElements.MeleeAuraToggle.Text = "Melee Aura (Distance: " .. string.format("%.1f", ConfigData.MeleeAura_Distance) .. ")"
        UIElements.MeleeAuraToggle.Status.Text = ConfigData.MeleeAura_Enabled and "ON" or "OFF"
    end
    if UIElements.MeleeAuraDistanceSlider then
        -- update slider position
    end

    -- FOV
    if UIElements.FovToggle then
        UIElements.FovToggle.BackgroundColor3 = ConfigData.Fov_Enabled and Color3.fromRGB(70, 200, 70) or Color3.fromRGB(35, 35, 35)
        UIElements.FovToggle.Status.Text = ConfigData.Fov_Enabled and "ON" or "OFF"
    end
    if UIElements.FovSlider then
        -- update slider position
    end

    -- Ragebot
    if UIElements.RagebotToggle then
        UIElements.RagebotToggle.BackgroundColor3 = ConfigData.Ragebot_Enabled and Color3.fromRGB(70, 200, 70) or Color3.fromRGB(35, 35, 35)
        UIElements.RagebotToggle.Status.Text = ConfigData.Ragebot_Enabled and "ON" or "OFF"
    end
    if UIElements.RagebotNameInput then
        UIElements.RagebotNameInput.Text = ConfigData.Ragebot_TargetName
    end

    -- Infinite Stamina
    if UIElements.InfiniteStaminaToggle then
        UIElements.InfiniteStaminaToggle.BackgroundColor3 = ConfigData.InfiniteStamina_Enabled and Color3.fromRGB(70, 200, 70) or Color3.fromRGB(35, 35, 35)
        UIElements.InfiniteStaminaToggle.Status.Text = ConfigData.InfiniteStamina_Enabled and "ON" or "OFF"
    end

    -- Invisibility
    if UIElements.InvisibilityToggle then
        UIElements.InvisibilityToggle.BackgroundColor3 = ConfigData.Invisibility_Enabled and Color3.fromRGB(70, 200, 70) or Color3.fromRGB(35, 35, 35)
        UIElements.InvisibilityToggle.Status.Text = ConfigData.Invisibility_Enabled and "ON" or "OFF"
    end
    if UIElements.InvisKeybindButton then
        UIElements.InvisKeybindButton.Text = ConfigData.Invisibility_Keybind
    end
    
    -- Keybind
    if UIElements.KeyCaptureButton then
        UIElements.KeyCaptureButton.Text = ConfigData.ToggleKey
        UIElements.KeybindLabel.Text = "Toggle Key (Current: " .. ConfigData.ToggleKey .. "):"
    end
end

function CrimLib.UI:PopulateConfigList(forceClose)
    local Config = CrimLib.Config
    local UIElements = Config.UI_Elements
    local ConfigListContainer = UIElements.ConfigListContainer
    local ConfigArrow = UIElements.ConfigArrow
    
    local function toggleConfigList(forceClose)
        local isVisible = ConfigListContainer.Visible
        if forceClose then isVisible = true end
        if isVisible then
            ConfigListContainer.Visible = false
            ConfigArrow.Text = "‚ñ∫"
        else
            self:PopulateConfigList()
            ConfigArrow.Text = "‚ñº"
        end
    end

    if forceClose then toggleConfigList(true) return end

    for _, child in ipairs(ConfigListContainer:GetChildren()) do
        if child.Name == "ConfigButton" or child.Name == "NoFileLabel" then
            child:Destroy()
        end
    end

    local configNames = Config:ListConfigFiles()
    if #configNames == 0 then
        local NoFileLabel = Instance.new("TextLabel")
        NoFileLabel.Name = "NoFileLabel"
        NoFileLabel.Parent = ConfigListContainer
        NoFileLabel.BackgroundTransparency = 1
        NoFileLabel.Size = UDim2.new(1, 0, 0, 28)
        NoFileLabel.Font = Enum.Font.Gotham
        NoFileLabel.Text = "   NO CONFIGS FOUND"
        NoFileLabel.TextColor3 = Color3.fromRGB(200, 70, 70)
        NoFileLabel.TextSize = 14
        NoFileLabel.TextXAlignment = Enum.TextXAlignment.Left
        ConfigListContainer.CanvasSize = UDim2.new(0, 0, 0, 30)
    else
        local buttonHeight = 28
        local padding = 2
        local totalHeight = #configNames * buttonHeight + (#configNames - 1) * padding
        ConfigListContainer.CanvasSize = UDim2.new(0, 0, 0, totalHeight)
        for _, name in ipairs(configNames) do
            local ConfigButton = Instance.new("TextButton")
            ConfigButton.Name = "ConfigButton"
            ConfigButton.Parent = ConfigListContainer
            ConfigButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            ConfigButton.Size = UDim2.new(1, 0, 0, buttonHeight)
            ConfigButton.Font = Enum.Font.Gotham
            ConfigButton.Text = "   " .. name
            ConfigButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            ConfigButton.TextSize = 14
            ConfigButton.TextXAlignment = Enum.TextXAlignment.Left
            Instance.new("UICorner", ConfigButton).CornerRadius = UDim.new(0, 4)
            ConfigButton.MouseButton1Click:Connect(function()
                Config.CurrentConfigName = name
                UIElements.ConfigDisplayButton.Text = "Current Config: " .. name
                toggleConfigList(true)
            end)
        end
    end
    ConfigListContainer.Visible = true
end

function CrimLib.UI:PopulateDeleteConfigList(forceClose)
    local Config = CrimLib.Config
    local UIElements = Config.UI_Elements
    local DeleteConfigListContainer = UIElements.DeleteConfigListContainer
    local DeleteArrow = UIElements.DeleteArrow

    local function toggleDeleteConfigList(forceClose)
        local isVisible = DeleteConfigListContainer.Visible
        if forceClose then isVisible = true end
        if isVisible then
            DeleteConfigListContainer.Visible = false
            DeleteArrow.Text = "‚ñ∫"
        else
            self:PopulateDeleteConfigList()
            DeleteArrow.Text = "‚ñº"
        end
    end

    if forceClose then toggleDeleteConfigList(true) return end

    for _, child in ipairs(DeleteConfigListContainer:GetChildren()) do
        if child.Name == "ConfigButton" or child.Name == "NoFileLabel" then
            child:Destroy()
        end
    end

    local configNames = Config:ListConfigFiles()
    if #configNames == 0 then
        local NoFileLabel = Instance.new("TextLabel")
        NoFileLabel.Name = "NoFileLabel"
        NoFileLabel.Parent = DeleteConfigListContainer
        NoFileLabel.BackgroundTransparency = 1
        NoFileLabel.Size = UDim2.new(1, 0, 0, 28)
        NoFileLabel.Font = Enum.Font.Gotham
        NoFileLabel.Text = "   NO CONFIGS FOUND"
        NoFileLabel.TextColor3 = Color3.fromRGB(200, 70, 70)
        NoFileLabel.TextSize = 14
        NoFileLabel.TextXAlignment = Enum.TextXAlignment.Left
        DeleteConfigListContainer.CanvasSize = UDim2.new(0, 0, 0, 30)
    else
        local buttonHeight = 28
        local padding = 2
        local totalHeight = #configNames * buttonHeight + (#configNames - 1) * padding
        DeleteConfigListContainer.CanvasSize = UDim2.new(0, 0, 0, totalHeight)
        for _, name in ipairs(configNames) do
            local ConfigButton = Instance.new("TextButton")
            ConfigButton.Name = "ConfigButton"
            ConfigButton.Parent = DeleteConfigListContainer
            ConfigButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            ConfigButton.Size = UDim2.new(1, 0, 0, buttonHeight)
            ConfigButton.Font = Enum.Font.Gotham
            ConfigButton.Text = "   " .. name
            ConfigButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            ConfigButton.TextSize = 14
            ConfigButton.TextXAlignment = Enum.TextXAlignment.Left
            Instance.new("UICorner", ConfigButton).CornerRadius = UDim.new(0, 4)
            ConfigButton.MouseButton1Click:Connect(function()
                Config.ConfigToDeleteName = name
                UIElements.DeleteConfigDisplayButton.Text = "Config to Delete: " .. name
                toggleDeleteConfigList(true)
            end)
        end
    end
    DeleteConfigListContainer.Visible = true
end

return CrimLib
